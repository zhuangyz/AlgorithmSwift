//
//  LCSTests.swift
//  AlgorithmSwift
//
//  Created by zyz on 16/11/1.
//  Copyright © 2016年 zyz. All rights reserved.
//

import XCTest

/*
 * 这种算法处理小文本时效率还行，但是对于大文本效率就很低了（参考testUnit和testLargeText）
 */

class LCSTests: XCTestCase {
    
    var timer : AlgorithmTimer = AlgorithmTimer()
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    func testUnit() {
        printString(strA: "blog.csdn.net", strB: "csdn.blogt")
    }
    
    func testCN() {
        printString(strA: "怎么求出最长的公共子序列呢", strB: "你知道最长公共子序列是什么吗")
    }
    
    func testLargeText() {
        printString(strA: "题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.题目描述:给定一个字符串s，你可以从中删除一些字符，使得剩下的串是一个回文串。如何删除才能使得回串最长呢？输出需要删除的字符个数。输入描述:输入数据有多组，每组包含一个字符串s，且保证:1<=s.length<=1000.",
                    strB: "思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。思路分析：最优子结构和重叠子问题的性质都具有，所以要采取动态规划的算法最长公共子序列的结构设序列X=其中Xm-1=子问题的递归结构由最长公共子序列问题的最优子结构性质可知，要找出X=由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。")
    }
    
    func printString(strA:String, strB:String) {
        self.timer.startTimer()
        let lcsStr = LCS.getLCSFrom(strA: strA, strB: strB)
        self.timer.endTimer()
        print("历时\(self.timer.during)秒")
        
        print("最长公共子字符串: \(lcsStr)")
    }
}
